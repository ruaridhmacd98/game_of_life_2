[{"/Users/ruaridh/Documents/code/game_of_life_2/src/index.js":"1","/Users/ruaridh/Documents/code/game_of_life_2/src/reportWebVitals.js":"2","/Users/ruaridh/Documents/code/game_of_life_2/src/App.js":"3","/Users/ruaridh/Documents/code/game_of_life_2/src/tutorial.js":"4","/Users/ruaridh/Documents/code/game_of_life_2/src/grid.js":"5","/Users/ruaridh/Documents/code/game_of_life_2/src/game.js":"6"},{"size":478,"mtime":1608537096142,"results":"7","hashOfConfig":"8"},{"size":362,"mtime":1608537096142,"results":"9","hashOfConfig":"8"},{"size":6150,"mtime":1609352674202,"results":"10","hashOfConfig":"8"},{"size":747,"mtime":1608537096142,"results":"11","hashOfConfig":"8"},{"size":595,"mtime":1609349948166,"results":"12","hashOfConfig":"8"},{"size":1380,"mtime":1609349948166,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"12w5jpa",{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"21","usedDeprecatedRules":"16"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"24","usedDeprecatedRules":"16"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"27"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"/Users/ruaridh/Documents/code/game_of_life_2/src/index.js",[],["30","31"],"/Users/ruaridh/Documents/code/game_of_life_2/src/reportWebVitals.js",[],"/Users/ruaridh/Documents/code/game_of_life_2/src/App.js",["32","33"],"import React from 'react';\nimport Select from 'react-select';\nimport Tutorial from './tutorial.js';\nimport './App.css';\nimport Grid from './grid.js';\nimport Game from './game.js';\nimport openSocket from 'socket.io-client';\nimport socketIOClient from \"socket.io-client\";\nvar io = require('socket.io-client');\n\nconst COLOURS = {\n  1: '#0000FF',\n  2: '#FF0000',\n  3: '#00FF00',\n}\n\nconst COLOUR_OPTIONS = [\n  {label: 'blue', value: 1},\n  {label: 'red', value: 2},\n  {label: 'green', value: 3},\n]\n\nconst PATTERNS = [\n  {label: 'cell', value: [[0, 0]]},\n  {label: 'square', value: [[0, 0], [1, 0], [0, 1], [1, 1]]},\n  {label: 'glider', value: [[0, 0], [0, 1], [0, 2], [1, 0], [2, 1]]},\n]\n\nclass Canvas extends React.Component {\n  constructor() {\n    super()\n    this.state = {\n\t  width: null,\n\t  height: null,\n\t  ctx: null,\n\t  isRunning: true,\n\t  isDragging: false,\n\t  mousePosition: [0, 0],\n\t  scale: 10,\n\t  centreOffset: [0, 0],\n\t  cells: getInitialGrid(),\n\t  patternToPlace: [[0, 0]],\n\t  colourToPlace: 1,\n    };\n\n  }\n\n  componentDidMount() {\n    let canvas = this.refs.canvas;\n    let ctx = canvas.getContext(\"2d\");\n    ctx.canvas.width = window.innerWidth;\n    ctx.canvas.height = window.innerHeight * 0.8;\n    var game = new Game();\n    this.setState({width: canvas.width});\n    this.setState({height: canvas.height});\nvar socket = openSocket('http://localhost:8080');\n// const socket = socketIOClient('http://localhost:8080');\nsocket.emit('hi', {say:'hi'});\n    setInterval(()=>{\n\tthis.draw();\n\tif (this.state.isRunning) {\n\t\tthis.setState({cells: game.iterate(this.state.cells)});\n\t}\n     }, 250)\n     }\n\n  selectPattern = pattern => {\n    this.setState({patternToPlace: pattern.value})\n  }\n\n  selectColour = colour => {\n    this.setState({colourToPlace: colour.value})\n  }\n\n  updateRunning = () => {\n    this.setState({isRunning: !this.state.isRunning})\n  }\n\n  handleClick(event){\n    let ctx = this.refs.canvas.getContext(\"2d\");\n    let x = event.clientX - ctx.canvas.offsetLeft;\n    let y = event.clientY - ctx.canvas.offsetTop;\n    [x, y] = this.clientToCell([x, y]);\n    let pattern = this.state.patternToPlace;\n    for(var i=0; i<pattern.length; i++){\n      this.state.cells.set(pattern[i][0]+x, pattern[i][1]+y, this.state.colourToPlace);\n    }\n    this.draw();\n  }\n\n  handleWheel(event){\n    let scroll = event.deltaY;\n\t  let newScale = this.state.scale;\n\t  let [newX, newY] = this.state.centreOffset;\n\t  if(scroll>0){\n\t    newScale/=0.9;\n\t    newX/=0.9;\n\t    newY/=0.9;\n\t  }\n\t  else if(newScale>1){\n\t    newScale*=0.9;\n\t    newX*=0.9;\n\t    newY*=0.9;\n\t  }\n    this.setState({scale: newScale, centreOffset: [newX, newY]})\n    this.setState({mousePosition: [event.clientX, event.clientY]});\n    this.draw();\n  }\n\n  handleMouseDown(event){\n   this.setState({isDragging: true, mousePosition: [event.clientX, event.clientY]});\n  }\n\n  handleMouseUp(event){\n   this.setState({isDragging: false});\n  }\n\n  handleMouseMove(event){\n    if(this.state.isDragging){\n      let [newX, newY] = this.state.centreOffset;\n      newX += event.clientX - this.state.mousePosition[0];\n      newY += event.clientY - this.state.mousePosition[1];\n      this.setState({centreOffset: [newX, newY]});\n    }\n    this.setState({mousePosition: [event.clientX, event.clientY]});\n    this.draw();\n  }\n\n  clientToCell([clientx, clienty]){\n    let cellx = Math.floor((clientx - this.state.width/2 - this.state.centreOffset[0]) / this.state.scale);\n    let celly = Math.floor((clienty - this.state.height/2 - this.state.centreOffset[1]) / this.state.scale);\n    return [cellx, celly];\n  }\n\n  cellToClient([x, y]){\n\tlet clientx = Math.floor(x*this.state.scale + this.state.centreOffset[0] + this.state.width/2);\n\tlet clienty = Math.floor(y*this.state.scale + this.state.centreOffset[1] + this.state.height/2);\n\treturn [clientx, clienty];\n  }\n\n  draw(){\n    let ctx = this.refs.canvas.getContext(\"2d\");\n    ctx.fillStyle=\"#E0E0E0\";\n    ctx.fillRect(0,0,this.state.width,this.state.height);\n    let coords = this.state.cells.listCells()\n    for(var i=0; i<coords.length; i++){\n\tlet x, y, clientx, clienty;\n\t[x, y] = coords[i];\n\tlet player = this.state.cells.get(x, y);\n\t[clientx, clienty] = this.cellToClient([x, y]);\n\tctx.fillStyle=COLOURS[player];\n\tctx.fillRect(clientx, clienty, 0.9*this.state.scale, 0.9*this.state.scale);\n    }\n    let pattern = this.state.patternToPlace;\n    let x, y, clientx, clienty, cellx, celly;\n    [cellx, celly] = this.clientToCell(this.state.mousePosition);\n    for(i=0; i<pattern.length; i++){\n      x = pattern[i][0]+cellx; y = pattern[i][1]+celly;\n      [clientx, clienty] = this.cellToClient([x, y]);\n      ctx.globalAlpha=0.5;\n      ctx.fillStyle=COLOURS[this.state.colourToPlace];\n      ctx.fillRect(clientx, clienty, 0.9*this.state.scale, 0.9*this.state.scale);\n      ctx.globalAlpha=1.0;\n    }\n  }\n\n  render (){\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n        </header>\n        <body>\n        <canvas ref=\"canvas\"\n\t    onClick={(event) => this.handleClick(event)}\n\t    onWheel={(event) => this.handleWheel(event)}\n\t    onMouseDown={(event) => this.handleMouseDown(event)}\n\t    onMouseUp={(event) => this.handleMouseUp(event)}\n\t    onMouseMove={(event) => this.handleMouseMove(event)}\n\t></canvas>\n\t<Tutorial/>\n\t<button className=\"button\" onClick={this.updateRunning}>\n\t    {this.state.isRunning ? <div>Stop</div>\n                            : <div>Start</div>}\n\t</button>\n\t<Select\n\t  onChange={this.selectPattern}\n\t  options={PATTERNS}\n\t  placeholder='Select Pattern'\n\t/>\n\t<Select\n\t  onChange={this.selectColour}\n\t  options={COLOUR_OPTIONS}\n\t  placeholder='Select Colour'\n\t/>\n        </body>\n      </div>\n    );\n  }\n}\n\nexport default Canvas;\n\n\nfunction getInitialGrid() {\n  const grid = new Grid();\n      grid.set(3, 0, 1);\n      grid.set(3, 1, 1);\n      grid.set(3, 2, 1);\n      grid.set(4, 1, 1);\n      grid.set(2, 2, 1);\n      grid.set(18, 0, 2);\n      grid.set(18, 1, 2);\n      grid.set(18, 2, 2);\n      grid.set(19, 1, 2);\n      grid.set(17, 2, 2);\n      grid.set(3, 20, 3);\n      grid.set(3, 21, 3);\n      grid.set(3, 22, 3);\n      grid.set(4, 21, 3);\n      grid.set(2, 22, 3);\n  return grid;\n}\n","/Users/ruaridh/Documents/code/game_of_life_2/src/tutorial.js",["34"],"import React from 'react';\nimport Popup from 'reactjs-popup';\nimport './tutorial.css';\n\nexport default () => (\n  <Popup\n    trigger={<button className=\"button\"> Tutorial </button>}\n    modal\n    nested\n  >\n    {close => (\n      <div className=\"modal\">\n        <button className=\"close\" onClick={close}>\n          &times;\n        </button>\n        <div className=\"header\"> Tutorial </div>\n        <div className=\"content\">\n          {' '}\n          Take it in turns to place cells.\n        </div>\n        <div className=\"actions\">\n          <button\n            className=\"button\"\n            onClick={() => {\n              close();\n            }}\n          >\n            Got it.\n          </button>\n        </div>\n      </div>\n    )}\n  </Popup>\n);\n","/Users/ruaridh/Documents/code/game_of_life_2/src/grid.js",[],["35","36"],"/Users/ruaridh/Documents/code/game_of_life_2/src/game.js",[],{"ruleId":"37","replacedBy":"38"},{"ruleId":"39","replacedBy":"40"},{"ruleId":"41","severity":1,"message":"42","line":8,"column":8,"nodeType":"43","messageId":"44","endLine":8,"endColumn":22},{"ruleId":"41","severity":1,"message":"45","line":9,"column":5,"nodeType":"43","messageId":"44","endLine":9,"endColumn":7},{"ruleId":"46","severity":1,"message":"47","line":5,"column":1,"nodeType":"48","endLine":34,"endColumn":3},{"ruleId":"37","replacedBy":"49"},{"ruleId":"39","replacedBy":"50"},"no-native-reassign",["51"],"no-negated-in-lhs",["52"],"no-unused-vars","'socketIOClient' is defined but never used.","Identifier","unusedVar","'io' is assigned a value but never used.","import/no-anonymous-default-export","Assign arrow function to a variable before exporting as module default","ExportDefaultDeclaration",["51"],["52"],"no-global-assign","no-unsafe-negation"]